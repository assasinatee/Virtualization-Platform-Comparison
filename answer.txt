To make a minimal Stratovirt, we can use the KVM interfaces by ioctl syscall:

The steps are:
1. Open "/dev/kvm" and create a new vm
2. Initialize guest OS memory 
3. Create a vCPU and initialize registers
4. Run vCPU loop with "trap and emulation"

Question1: How do we get the output in serial?
Where to trap serial output(which address for PIO)? 

Let's look at the code: 

-------------------------------------------------------------

    let asm_code: &[u8] = &[
        0xba, 0xf8, 0x03, // mov $0x3f8, %dx
        0x00, 0xd8, // add %bl, %al
        0x04, b'0', // add $'0', %al
        0xee, // out %al, (%dx)
        0xb0, b'\n', // mov $'\n', %al
        0xee,  // out %al, (%dx)
        0xf4,  // hlt
    ];
-------------------------------------------------------------

Answer: The serial output address is pio address 0x3f8.

Now we need to alloc and initialize guest memory
The steps are:
1. Alloc contiguous virtual memory in host OS
2. use `kvm_userspace_memory_region` interface to setup memory mapping by ioctl

There are some example ways to alloc memory: 
1. use stack memory by local variables
2. use heap memory by malloc
3. let kernel alloc contiguous virtual memory by mmap

Question2: What are the ways to alloc large contiguous virtual memory?

Let's look at the code in StratoVirt:

-------------------------------------------------------------
    let host_addr: *mut u8 = unsafe {
        libc::mmap(
            std::ptr::null_mut(),
            mem_size,
            libc::PROT_READ | libc::PROT_WRITE,
            libc::MAP_ANONYMOUS | libc::MAP_PRIVATE,
            -1,
            0,
        ) as *mut u8
    };

    let kvm_region = kvm_userspace_memory_region {
        slot: 0,
        guest_phys_addr: guest_addr,
        memory_size: mem_size as u64,
        userspace_addr: host_addr as u64,
        flags: 0,
    };
    unsafe {
        vm_fd
            .set_user_memory_region(kvm_region)
            .expect("Failed to set memory region to KVM")
    };
-------------------------------------------------------------
Answer: The mmap syscall is the best way to alloc large guest memory
because the size of stack and heap are limited

Virtualization technologies capture sensitive instructions at the instruction-level
and are emulated by the hypervisor in a loop called "entrance-emulation"

As for StratoVirt, we use KVM::run interface to VM-ENTRY, this returns when VM-EXIT

Question3: How can we process the trapped PIO instructions(in, out instruction)?
-------------------------------------------------------------
    // 4. Run vCPU.
    loop {
        match vcpu_fd.run().expect("run failed") {
            VcpuExit::IoIn(addr, data) => {
                println!("VmExit IO in: addr 0x{:x}, data is {}", addr, data[0])
            }
            VcpuExit::IoOut(addr, data) => {
                println!("VmExit IO out: addr 0x{:x}, data is {}", addr, data[0])
            }
            VcpuExit::MmioRead(addr, _data) => println!("VmExit MMIO read: addr 0x{:x}", addr),
            VcpuExit::MmioWrite(addr, _data) => println!("VmExit MMIO write: addr 0x{:x}", addr),
            VcpuExit::Hlt => {
                println!("KVM_EXIT_HLT");
                break;
            }
            r => panic!("Unexpected exit reason: {:?}", r),
        }
    }
-------------------------------------------------------------
Answer: We use println to perform serial output.

In practice, a virtual machine often requires multiple memory regions, and memory 
needs to be allocated for interrupt controllers, PCI devices, and so on, thus requiring
more flexible memory management

The memory layer in StratoVirt is here: [0,1M] for bootloader and [3G,4G] for devices
   ------------   
   |          |   
   |   mem    |   
   |          |   
   |          |   
   ------------ 4G
   |  devices |   
   ------------ 3G
   |          |   
   |   mem    |   
   |          |   
   |          |   
   ------------ 1M
   |  loader  |   
   ------------ 0 

Question4: How to setup multiple memory mapping in KVM?

Let' s look at the code in StratoVirt

-------------------------------------------------------------
        for (index, range) in ranges.iter().enumerate() {
            let host_mmap = Arc::new(HostMemMapping::new(range.0, range.1)?);
            host_mmaps.push(host_mmap.clone());

            let kvm_region = kvm_userspace_memory_region {
                slot: index as u32,
                guest_phys_addr: host_mmap.guest_address(),
                memory_size: host_mmap.size(),
                userspace_addr: host_mmap.host_address(),
                flags: 0,
            };
            unsafe {
                vm_fd
                    .set_user_memory_region(kvm_region)
                    .map_err(Error::KvmSetMR)?;
            }
-------------------------------------------------------------
Answer: build multiple region with different slots and use `set_user_memory_region` 
interface to update memory mapping in KVM

Now when StratoVirt traps mmio instructions, we will get the target guest address


-------------------------------------------------------------
    loop {
        match vcpu_fd.run().expect("run failed") {
            VcpuExit::IoIn(addr, data) => {
                println!("VmExit IO in: addr 0x{:x}, data is {}", addr, data[0])
            }
            VcpuExit::IoOut(addr, data) => {
                println!("VmExit IO out: addr 0x{:x}, data is {}", addr, data[0])
            }
            VcpuExit::MmioRead(addr, _data) => println!("VmExit MMIO read: addr 0x{:x}", addr),
            VcpuExit::MmioWrite(addr, _data) => println!("VmExit MMIO write: addr 0x{:x}", addr),
            VcpuExit::Hlt => {
                println!("KVM_EXIT_HLT");
                break;
            }
            r => panic!("Unexpected exit reason: {:?}", r),
        }
    }
-------------------------------------------------------------


Question5: How can we find corresponding host target address?

Answer: Find corresponding host address by compare guest address regions
Let' s look at the code in StratoVirt:

-------------------------------------------------------------
    /// Find corresponding host mem mapping according to guest address.
    fn find_host_mmap(&self, addr: u64, size: u64) -> Result<Arc<HostMemMapping>> {
        for host_mmap in &self.host_mmaps {
            if addr >= host_mmap.guest_address()
                && addr < host_mmap.guest_address() + host_mmap.size()
            {
                if addr + size > host_mmap.guest_address() + host_mmap.size() {
                    return Err(Error::Overflow(
                        addr - host_mmap.guest_address(),
                        size,
                        host_mmap.size(),
                    ));
                }
                return Ok(host_mmap.clone());
            }
        }
        Err(Error::HostMmapNotFound(addr))
    }
-------------------------------------------------------------

Now we can trap sensitive instructions in kvm::run loop with its addr and data
Then we can find the corresponding host address by "find_host_mmap" function
Now we should emulate mmio read/write instructions


Question6: How can we emulate a mmio read/write instruction?

Let' s look at the code in StratoVirt:

-------------------------------------------------------------
    /// Read memory segment to `dst`.
    ///
    /// # Arguments
    ///
    /// * `dst` - Destination the data would be written to.
    /// * `addr` - Start address.
    /// * `count` - Size of data.
    ///
    /// # Errors
    ///
    /// Return Error if the `addr` is not mapped.
    pub fn read(&self, dst: &mut dyn std::io::Write, addr: u64, count: u64) -> Result<()> {
        let host_mmap = self.find_host_mmap(addr, count)?;
        let offset = addr - host_mmap.guest_address();
        let host_addr = host_mmap.host_address();

        let slice = unsafe {
            std::slice::from_raw_parts((host_addr + offset) as *const u8, count as usize)
        };
        dst.write_all(slice).map_err(Error::IoError)?;

        Ok(())
    }
-------------------------------------------------------------
Answer: Take mmio read as an example, the steps are:
1. Use memory mapping and guest address to calculate host target address
2. Read target address in binary format
3. Move data to dst address

Now we can manage memory fairly well, but there is no cpu management yet
In Virtualization, some instructions may modify registers
And storing registers info will support us to implement multi-CPU virtualization


Question7: What CPU information should we save?

Let' s look at the code in StratoVirt:

-------------------------------------------------------------
pub struct CPU {
    /// ID of this virtual CPU, `0` means this cpu is primary `CPU`.
    pub id: u8,
    /// The file descriptor of this kvm_based vCPU.
    fd: VcpuFd,
    /// Common registers for kvm_based vCPU.
    pub regs: kvm_regs,
    /// Special registers for kvm_based vCPU.
    pub sregs: kvm_sregs,
}
-------------------------------------------------------------
        vcpu_0.realize();
        vcpu_0.sregs.cs.base = 0;
        vcpu_0.sregs.cs.selector = 0;
        vcpu_0.regs.rip = guest_addr_01;
        vcpu_0.regs.rax = 2;
        vcpu_0.regs.rbx = 3;
        vcpu_0.regs.rflags = 2;
-------------------------------------------------------------
Answer: we record regs and special regs:
regs : rax-rdx, rsi, rsp, r8-r15, rip, rflags
sregs: cs-ss(segment regs), ldt, gdt, idt, cr0-cr4, ect.

Now we have designed CPU and memory models, so than we can map multiple memory
segments and store CPU registers to support multiple CPUs. However, We can only
run some assembly code. If we want to boot a linux kernel, we still need to implement
the linux boot protocol(https://www.kernel.org/doc/html/latest/x86/boot.html)


For example: a naive bootloader looks like this:
---------------------------------------------------------------------------
start addr    end addr    region              function                     
---------------------------------------------------------------------------
~             end         initrd                                           
0x100000      ~           kernel setup        entrypoint of protect mode   
0xf0000       0xfffff     BIOS boot block                                  
0xa0000       0xeffff     VGA Graphic buffer                               
0x9fc00       0x9ffff     MPtable                                          
0x20000       0x9fbff     Kernel cmdline                                   
0xb000        0x1f000     Page Directory Entry                             
0xa000        0xafff      Page Directory Pointer                           
0x9000        0x9fff      Page Map Level4     4-level page table info      
0x7000        0x8fff      Zero Page           kernel cfg and hardware info 
0x0000        0x6fff      Interrupt Table     real-mode interrupt table    
---------------------------------------------------------------------------
The Zero Page is pretty important, which includes:
1. kernel header: magic number, ramdisk base and size, cmdline base and size
2. e820 table: contains hardware memory layout


Question8: How to build e820 table?
Answer: Let' s look at the code in StrtoVirt
-------------------------------------------------------------
    boot_params.add_e820_entry(
        REAL_MODE_IVT_BEGIN,
        EBDA_START - REAL_MODE_IVT_BEGIN,
        E820_RAM,
    );
    boot_params.add_e820_entry(EBDA_START, VGA_RAM_BEGIN - EBDA_START, E820_RESERVED);
    boot_params.add_e820_entry(MB_BIOS_BEGIN, 0, E820_RESERVED);

    let high_memory_start = super::loader::VMLINUX_RAM_START;
    let layout_32bit_gap_end = config.gap_range.0 + config.gap_range.1;
    let mem_end = sys_mem.memory_end_address();
    if mem_end < layout_32bit_gap_end {
        boot_params.add_e820_entry(high_memory_start, mem_end - high_memory_start, E820_RAM);
    } else {
        boot_params.add_e820_entry(
            high_memory_start,
            config.gap_range.0 - high_memory_start,
            E820_RAM,
        );
        boot_params.add_e820_entry(
            layout_32bit_gap_end,
            mem_end - layout_32bit_gap_end,
            E820_RAM,
        );
    }
-------------------------------------------------------------

Now we can boot linux kernel, but we haven' t emulate a serial device
We should emulate registers and red/write operations


Question9: How to emulate the write operation? 
Let' s look at the code in StratoVirt
-------------------------------------------------------------
    pub fn write(&mut self, offset: u64, data: u8) -> Result<()> {
        match offset {
            0 => {
                if self.lcr & UART_LCR_DLAB != 0 {
                    self.div = (self.div & 0xff00) | u16::from(data);
                } else {
                    self.thr_pending = 1;

                    if self.mcr & UART_MCR_LOOP != 0 {
                        // loopback mode
                        if self.rbr.len() >= RECEIVER_BUFF_SIZE {
                            return Err(Error::Overflow(self.rbr.len(), RECEIVER_BUFF_SIZE));
                        }

                        self.rbr.push_back(data);
                        self.lsr |= UART_LSR_DR;
                    } else {
                        self.output.write_all(&[data]).map_err(Error::IoError)?;
                        self.output.flush().map_err(Error::IoError)?;
                    }

                    self.update_iir()?;
                }
            }
            1 => {
                if self.lcr & UART_LCR_DLAB != 0 {
                    self.div = (self.div & 0x00ff) | (u16::from(data) << 8);
                } else {
                    let changed = (self.ier ^ data) & 0x0f;
                    self.ier = data & 0x0f;

                    if changed != 0 {
                        self.update_iir()?;
                    }
                }
            }
            3 => {
                self.lcr = data;
            }
            4 => {
                self.mcr = data;
            }
            7 => {
                self.scr = data;
            }
            _ => {}
        }

        Ok(())
-------------------------------------------------------------
Answer: when we trap pio instructions, the instr will be passed to serial
the serial will emulate the change of registers

Now we have serial device, but the linux kernel will fight you for control of your terminal
This is because the granularity of the lock is too coarse
We can use epoll to solve this problem


Question10: How to use epoll? 
Let' s look at the code in StratoVirt
-------------------------------------------------------------
        let serial_clone = serial.clone();
        let mut epoll = EpollContext::new();
        let handler: Box<dyn Fn(EventSet, RawFd) + Send + Sync> = Box::new(move |event, _| {
            if event == EventSet::IN && serial_clone.lock().unwrap().stdin_exce().is_err() {
                println!("Failed to excecute the stdin");
            }
        });

        let notifier = EventNotifier::new(
            libc::STDIN_FILENO,
            EventSet::IN,
            Arc::new(Mutex::new(handler)),
        );

        epoll.add_event(notifier);

        let _ = thread::Builder::new()
            .name("serial".to_string())
            .spawn(move || loop {
                if !epoll.run() {
                    break;
                }
            });
-------------------------------------------------------------
Answer: we use an event listener in another thread to inspect stdin event
Thanks!